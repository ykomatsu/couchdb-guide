<title>リスト機能によるビューの変換</title>

<meta charset="utf-8">

<link rel="stylesheet" href="../../../style.css">

<link rel="prev" href="show.html">

<link rel="next" href="standalone.html">

<script src="../../../script.js"></script>

<h2 id="transforming">リスト機能によるビューの変換</h2>

<p>ショー機能がドキュメントを任意の出力形式に変換するのとちょうど同じように、CouchDBの<em>リスト機能</em>を使うと、ビュークエリーの出力を任意の形式でレンダリングすることができます。強力なイテレーターAPIは、オンザフライで行をフィルタリングし、集計することだけでなく、AtomフィードやHTMLリスト、CSVファイル、設定ファイル、単に変更されたJSONを生成するための簡単な方法として、生の変換を出力することができるような柔軟性を実現します。

<p>リスト機能はデザインドキュメントの<code>lists</code>フィールドに保存します。以下に、2つのlist関数を含むデザインドキュメントの例を示します。

<pre>
{
  "_id" : "_design/foo",
  "_rev" : "1-67at7bg",
  "lists" : {
    "bar" : "function(head, req) { var row; while (row = getRow()) { ... } }",
    "zoom" : "function() { return 'zoom!' }",
  }
}
</pre>

<h3 id="arguments">list関数の引数</h3>

<p>list関数は2つの引数とともに呼ばれます。これらの引数は、関数の実行中に生のデータ自体が読み込まれるときには、無視できることもあります。1つ目の引数である<code>head</code>は、ビューについての情報を持ちます。以下に、目にするかも知れない<code>head</code>のJSON表現を示します。

<pre>
{total_rows:10, offset:0}
</pre>

<p>リクエスト自体はもっとリッチなデータ構造です。これはshow関数やupdate関数、filter関数で使うものと同じリクエストオブジェクトです。参照のために、ここで詳細に説明していきます。以下に<code>req</code>オブジェクトの例を示します。

<pre>
{
  "info": {
    "db_name": "test_suite_db","doc_count": 11,"doc_del_count": 0,
    "update_seq": 11,"purge_seq": 0,"compact_running": false,"disk_size": 4930,
    "instance_start_time": "1250046852578425","disk_format_version": 4},
</pre>

<p>データベースのURLに対する情報のリクエストで利用できるようなデータベースの情報は、リクエストパラメーターに含まれます。これにより、更新シーケンスで行をレンダリングすることを抑止でき、作業しているデータベースを知ることができます。

<pre>
  "method": "GET",
  "path": ["test_suite_db","_design","lists","_list","basicJSON","basicView"],
</pre>

<p>クライアントのリクエストからのHTTPメソッドとパスは、アプリケーション内の他のリソースへのリンクをレンダリングするために、特に便利です。

<pre>
  "query": {"foo":"bar"},
</pre>

<p>クエリー文字列にパラメーターがある場合（このケースでは<code>?foo=bar</code>に当たります)、それらはパースされ、<code>req.query</code>でJSONオブジェクトとして利用できるようになります。

<pre>
  "headers":
    {"Accept": "text/html,application/xhtml+xml ,application/xml;q=0.9,*/*;q=0.8",
    "Accept-Charset": "ISO-8859-1,utf-8;q=0.7,*;q=0.7","Accept-Encoding":
    "gzip,deflate","Accept-Language": "en-us,en;q=0.5","Connection": "keep-alive",
    "Cookie": "_x=95252s.sd25; AuthSession=","Host": "127.0.0.1:5984",
    "Keep-Alive": "300",
    "Referer": "http://127.0.0.1:5984/_utils/couch_tests.html?script/couch_tests.js",
    "User-Agent": "Mozilla/5.0 Gecko/20090729 Firefox/3.5.2"},
  "cookie": {"_x": "95252s.sd25","AuthSession": ""},
</pre>

<p>headersはlist関数やshow関数に、クライアントの望むContent-Typeのレスポンスを提供する能力だけではなく、クッキーのようなその他の気の利いた機能を提供する能力も与えます。クッキーもまた、JSON表現にパースされることに注意してください。ありがとう、MochiWeb！

<pre>
  "body": "undefined",
  "form": {},
</pre>

<p>このケースではメソッドは<code>POST</code>ですが、リクエスト本文（と、該当するならばフォームデコードされたJSON表現）もまた利用可能です。

<pre>
  "userCtx": {"db": "test_suite_db","name": null,"roles": ["_admin"]}
}
</pre>

<p>最後に、<code>userCtx</code>はバリデーション機能に送られるものと同じです。これは、ユーザー名と許可されたロールとで認証されたユーザーに、データベースへのアクセスを提供します。前の例では、「管理者パーティー」モードになっているCouchDBのノードで作業しているanonymousユーザーがいました。管理者を指定しない限り、全員が管理者になります。

<p>list関数の引数についてはこれで十分です。さあ、list関数自体の仕組みを見てみましょう。

<h3 id="example">list関数の例</h3>

<p>この知識を使いましょう。この章のイントロダクションで、設定ファイルの生成にリストを使うという話をしました。これの楽しいところは、設定情報をCouchDBに保持しておき、設定ファイルをリストで生成すると、それを再生成することができるかについて心配する必要がなくなるというところです。なぜなら、設定は他の情報源ではなくデータベースから純粋な関数によって生成されるということが分かっているからです。この分離のレベルは、CouchDBが動作している限り、設定ファイルを正常に生成することができるということを保証します。その他のシステムサービスやファイル、ネットワークリソースからデータを取得することができないので、外部要因によって失敗するような設定ファイルのジェネレーターを誤って書いてしまうことができないのです。

<div class="aside note">

<p>J. Chrisは、通常CouchDBを使って設定するような種類のサービス、特にApacheライセンスのインフラ自動化ツールのChefの設定ファイルの生成にリスト機能を利用するというアイデアに興奮しました。インフラの自動化の重要な特徴は、デプロイメントスクリプトが等羃であること、つまり、途中で失敗したときに何か重大なことが起きるようなスクリプトを、複数回実行しても1回実行したときと同じように意図した効果が得られるということです。このことから、クラッシュオンリーな、つまり、スクリプトが複数回失敗したとしてもデータの一貫性は維持されるような設計が奨励されます。なぜなら、それによって前回失敗したサーバーのプロビジョニングやアップデートから当て推量を取り除くことができるからです。

<p>map関数、reduce関数、show関数のように、lists関数はビュークエリーとHTTPリクエストを受けて出力形式を返す、純粋な関数です。それらの関数は、リモートサービスやその他の外部のデータにクエリーを投げたり、外部のデータにアクセスすることはできません。そのため、それらの関数は反復可能だと分かります。list関数を使ってHTTPサーバーの設定ファイルを生成すると、データベースの状態だけに基づいて、設定が繰り返し生成されることが保証されます。

</div>

<p>あなたがユーザーごとに名前ベースの仮想ホストをひとつ提供する共有ホスティングプラットフォームを運営しているところを想像してください。あなたは設定ファイルの最初に、（使用するモジュールなど）いくつかのノードの設定を書いて、次にユーザーのHTTPディレクトリやサブドメイン、フォーワードポートなどのような設定をユーザーごとにひとつの設定セクションとして書く必要があります。

<pre>
function(head, req) {
  // helper function definitions would be here...
  var row, userConf, configHeader, configFoot;
  configHeader = renderTopOfApacheConf(head, req.query.hostname);
  send(configHeader);
</pre>

<p>最初の関数のブロックでは、<code>renderTopOfApacheConf(head, req.query.hostname)</code>を使って設定ファイルの先頭部分をレンダリングしています。ここには、設定されたサーバーの内部名やユーザーのHTMLファイルが構成されるルートディレクトリのような、関数に渡した情報が含まれるかも知れません。関数の本文は示しませんが、サーバのすべてのグローバルな設定やビューデータを基にしたユーザーごとの設定のための段階を配置する、長い複数行の文字列が返されるであろうことは想像できるでしょう。

<p><code>send(configHeader)</code>の呼び出しは、list関数を使ってテキストをレンダリングする能力の中心です。簡単に言えば、これは単にHTTPチャンクをそれに貼り付けられた文字列の内容とともにクライアントに送信しているだけです。この状況の裏にはCouchDBがJavaScriptランナーと同期プロトコルで通信するというような、いくつかの処理があるのですが、プログラマーの観点からは、<code>send()</code>がHTTPチャンクの生成される理由です。

<p>さあ、ファイルの先頭部分をレンダリングして送信したので、リスト自体のレンダリングを始めましょう。各リスト項目はビューの行を仮想ホストの設定要素に変換した結果です。最初にするのは、ビューの行を得るために<code>getRow()</code>を呼び出すことです。

<pre>
  while (row = getRow()) {
    var userConf = renderUserConf(row);
    send(userConf)
  }
</pre>

<p>ここで使われる<code>while</code>ループは、<code>getRow()</code>がnullを返すまで実行され続けます。nullを返すことで、CouchDBはlist関数にすべての有効な行を使い果たしたことを通知します。先を急ぐ前に、行を取得したときに何が起こるのかを確認してみましょう。

<p>このケースでは、行を基にして単に文字列をレンダリングし、クライアントに送信するだけです。すべての行がレンダリングされると、ループは完了します。ちょうど良い機会なので、関数には早期に戻るためのオプションがあることに注意しましょう。おそらくそれは、特定のユーザーのドキュメントを見たときか、設定に割り当てられているいくつかのリソースが保持されているという印に基づいて、繰り返しが止まるようにプログラムされます。このような場合、ループは<code>break</code>文かその他の方法で早期に終了します。list関数には、送られたすべての行をレンダリングしなければならないという要件はありません。

<pre>
  configFoot = renderConfTail();
  return configFoot;
}
</pre>

<p>最後に、設定ファイルを閉じて、最後のHTTPチャンクとして送信されるように最後の文字列の値を返します。list関数の最後の動作は、いつもクライアントに送信する最後のHTTPチャンクとして送信される文字列を返すというものです。

<p>私たちの設定ファイル生成関数を実際に使うために、私たちは次のようなコマンドラインスクリプトを実行するかも知れません。

<pre>
curl http://localhost:5984/config_db/_design/files/_list/apache/users?hostname=foobar &gt; apache.conf
</pre>

<p>これは、ユーザーのビューを基に私たちのApacheの設定をレンダリングし、ファイルに保存します。信頼できる設定ジェネレーターをビルドする、なんて簡単な方法でしょう！

<h3 id="theory">リストの理論</h3>

<p>完全なlist関数を見てきたので、それの持ついくつかの便利なプロパティーに言及することには価値があります。

<p>最も明らかなものは、イテレーター形式のAPIです。各行は<code>getRow()</code>の呼び出しにより独立して読み込まれるので、メモリーリークが発生しないようにするのは簡単です。list関数のAPIを正しく使えば、任意の長さのリストをエラーなしにレンダリングすることができます。

<p>一方、このAPIを使うと、いくつかの行をひとつの出力のチャンクにまとめるための柔軟性を得られますが、例えば、ユーザーのアカウントが所有するサブドメインの後にそのユーザーアカウントがあるような場合、より複雑なチャンクをレンダリングするためにlist関数中でいくつかの文からなる少し複雑なループを使うこともあります。代わりのループセクションを見てみましょう。

<pre>
var subdomainOwnerRow, subdomainRows = [];
while (row = getRow()) {
</pre>

<p>ビューの<code>endkey</code>に到達するまで続くループに入ります。このビューは、ユーザーのすべてのサブドメインの後に、そのユーザーのプロファイルの行を出力するよう構成されています。プロファイルのデータとサブドメインの情報を、個々のユーザーのための設定のテンプレートに使用します。これの意味するところは、現在のユーザーのすべての行を受け取るまで、サブドメインの設定はレンダリングできないということです。

<pre>
  if (!subdomainOwnerRow) {
    subdomainOwnerRow = row;
</pre>

<p>このケースは最初のユーザーの場合にだけ真になります。単に初期条件を設定しています。

<pre>
  } else if (row.value.user != subdomainOwnerRow.value.user) {
</pre>

<p>これは最後のケースです。これは、現在のユーザーのすべてのサブドメインの行が使い果たされた後にのみ呼び出されます。これは、すべてのサブドメインの行が使い果たされたことを示す、現在のユーザーと一致しないユーザーの行を引き金とします。

<pre>
    send(renderUserConf(subdomainOwnerRow, subdomainRows));
</pre>

<p>現在のユーザーのためのすべてをレンダリングする準備ができたことが分かったので、プロファイルの行とサブドメインの行を（ごつごつしたnginxの設定の詳細を公平な読者からうまく隠してくれる）レンダリング関数に渡します。この結果はHTTPクライアントに送信され、HTTPクライアントはそれを設定ファイルに書き込みます。

<pre>
    subdomainRows = [];
    subdomainOwnerRow = row;
</pre>

<p>このユーザーについては終わったので、行をクリアーし、次のユーザーの作業を始めましょう。

<pre>
  } else {
    subdomainRows.push(row);
</pre>

<p>ああ、作業に戻り、行を収集しましょう。

<pre>
  }
}
send(renderUserConf(subdomainOwnerRow, subdomainRows));
</pre>

<p>この最後の部分はトリッキーです。（最後のビュークエリーに到達し）ループが終わった後、まだ最後のユーザーの設定をレンダリングする必要があります。それを忘れてはいけません！

<p>このループセクションの要点は、他のユーザーに所属する行を見るまで、特定のユーザーに所属する行を収集するということです。そのときに、最初のユーザーの出力をレンダリングし、状態をクリアーし、新しいユーザーについて作業を始めます。このようなテクニックから、リストイテレーターAPIには十分な柔軟性があるということが分かります。

<p>特定の結果セットから隠される、フィルタリングされた行を含むこれらの行は、（例えば、タグクラウドを人気度でソートするための）上位<em>N</em>グループのreduce値を見付けたり、（reduce結果がインクリメンタルに保存されないことを気にしないのであれば）カスタマイズされたreduce関数を書いたりするために使われます。

<h3 id="querying">リストのクエリー</h3>

<p>list関数がクエリーを受ける方法の詳細を見ていません。ちょうどshow関数と同じように、list関数はデザインドキュメントで利用可能なリソースです。list関数への基本的なパスは次の通りです。

<pre>
/db/_design/foo/_list/list-name/view-name
</pre>

<p>リスト名とビュー名とは指定されているので、これはひとつ以上のビューに対するリストをレンダリングすることができるということを意味します。例えば、ブログのコメントをAtom XML形式でレンダリングするlist関数を持ち、そしてそれを最近のコメントのグローバルビューに対して実行するのみならず、個々のブログの投稿への最近のコメントのビューに対して実行することもできます。これにより、サイト全体のコメントのAtomフィードを提供するだけでなく、各投稿の個々のコメントフィードを提供するためにも、同じlist関数を使うことができるようになります。

<p>listへのパスの後にはビュークエリーパラメーターが続きます。ちょうど通常のビューと同じように、クエリーパラメーターなしでlist関数を呼び出すと、その結果はビューのすべての行を反映するリストになります。クエリーパラメーターとともにlist関数を呼び出す場合の多くは、返ってくるデータを制限したいときでしょう。

<p>ビュークエリーオプションについては、<a href="views.html">「6章 ビューによるデータの検索」</a>ですでに慣れているでしょう。同じクエリーオプションが<code>_list</code>に適用されます。URLを並べて見てみましょう。<a href="#example/1">例1・JSONビュークエリー</a>を参照してください。

<div class="figure" id="example/1">

<pre>
GET /db/_design/sofa/_view/recent-posts?descending=true&amp;limit=10
</pre>

<p class="caption">例1・JSONビュークエリー

</div>

<p>このビュークエリーは単に最新の10件のブログの投稿を要求するものです。もちろん、このクエリーには<code>startkey</code>や<code>skip</code>のようなパラメーターを含めることができますが、ここでは単純にするために省略しています。同じクエリーをlist関数に対して実行するには、<a href="#example/2">「例2 HTMLリストクエリー」</a>で示すように、リストリソースを通じてアクセスします。

<div class="figure" id="example/2">

<pre>
GET /db/_design/sofa/_list/index/recent-posts?descending=true&amp;limit=10
</pre>

<p class="caption">例2・HTMLリストクエリー

</div>

<p>ここでの<code>index</code>リストはJSONからHTMLへの変換関数です。ちょうど前述のビュークエリーと同じように、追加のクエリーパラメーターを使ってリストをページ分割することができます。<a href="index.html#part/iii">「第3部 サンプルアプリケーション」</a>で見るように、動作するリストがあればページ分割を追加するのは簡単なことです。<a href="#example/3">「例3 Atomリストクエリー」</a>を参照してください。

<div class="figure" id="example/3">

<pre>
GET /db/_design/sofa/_list/index/recent-posts?descending=true&amp;limit=10&amp;format=atom
</pre>

<p class="caption">例3・Atomリストクエリー

</div>

<p>list関数はクエリーパラメーターも見ることができ、パラメーターに基づいてレンダリングの出力を切り替えるようなこともできます。クエリーパラメーターを使って、ユーザー名をリストに渡すようなことさえできます（しかしキャッシュ効率が台なしになるので、これはお勧めしません）。

<h3 id="caching">リスト、Etag、キャッシング</h3>

<p>ちょうどshow関数やビュークエリーと同じように、リストは適切なHTTP Etagとともに送信されます。これにより、中間プロキシーによってキャッシュすることができるようになります。これは、リストレンダリングのコードでサーバーが行き詰まりはじめた場合、Squidのようなキャッシングリバースプロキシーを使うことで負荷を軽減することができるということを意味します。Etagとキャッシングの詳細についてはここでは説明しませんが、これらは<a href="show.html">「第8章 ショー機能」</a>でカバーしています。
